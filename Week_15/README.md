学习笔记

课程总结

# 技术上有哪些优化办法

- 丢弃订单:最早期，单体系统时，量太大扛不住，直接前端随机reject一些，返回给抢单失败，简单粗暴，但是有效，比如10万人抢100个iPhone，只要能提前预测有大概1万以上的人 参与(通过资格确认、报名等方式收集信息)，那么直接请求进来以后随机挡回去 99%的流量都没有啥问题。

- 优化吞吐:中间有段时间，提前准备一大批机器，服务化、分库分表搞定后端性能， 让前端业务可以加一定量的机器，然后搞稳定性，依赖关系，容量规划，做弹性，提升吞吐量。

- 异步队列:然后就是使用可堆积的消息队列或者内存消息队列了，如果抢单具有强顺序，那么先都进队列，然后拿前N(就是库存数)个出来平滑处理，剩下的所有都可以 作为失败进行批处理了，甚至还可以做一个定长的队列，再往里写直接提示失败。队列 把并发变成串行，从而去掉了锁。

- 内存分配:一些具体的业务，也会考虑预热，提前在每个机器节点内存分配好库存数 量，然后直接在内存里处理自己的库存数即可，这样可能也会在极端情况下，

- 拆分扩展:针对不同类型、不同商家、不同来源的商品，部署不同的前端促销集群， 这样就把压力分散开了。具体到每个商家，其实量就不大了，双十一销售第一名的商家， 并发也不是特别高。

- 服务降级:越重要的抢单，大家越关心自己有没有抢到，而不是特别在意订单立即处理完，也就是说，下单占到位置比处理完成订单要更有价值。比如12306春运抢票，只要告诉用户你抢到了票，但是预计1个小时后订单才会处理完，用户有这个明确预期， 就可以了，用户不会立马使用这张票，也不会在意1分钟内处理完还是1小时处理完。

- 需要注意的是其中部分模式会导致销售不足或者超卖，销售不足可以从抢购里加一些名单补发，也可以加一轮秒杀。超卖比较麻烦，所以一般会多备一点货，比如抢100个iPhone，提前准备105个之类的，也会证明在实际操作里非常有价值。

# 秒杀主要做的是：
1. 并发读，减少读得数据，和减少读得次数
2. 并发写，数据库层面，物理上做单独的库
3. 高可用
4. 要遵循几个原则，就是要保证用户请求的数据尽量少、请求数尽量少、路径尽量短、依赖尽量少，并且不要有单点

# 秒杀的关键是
- 稳：系统满足高可用
- 准：保证数据的一致性
- 快：系统的性能要足够高

# 架构注意原则
- 数据要尽量少
- 请求数要尽量少
- 路径要尽量短
- 依赖尽量少
- 不要有单点
# 架构设计图

# 动静数据分离与方案
- 动态数据指与URL、浏览者、时间、地域相关，以及是否含有 Cookie 等有关的私密数据，以及内容会有变化的数据，静态数据与上述无关

## 对静态数据做缓存
1. 把静态数据缓存到离用户最近的地方
2. 直接缓存 HTTP 连接而不是仅仅缓存数据（静态化改造）
3. Web 服务器更擅长缓存静态数据

## 如何做动静分离改造

### 静态数据如何处理

1. URL 唯一化，这样可以直接缓存 HTTP 连接
2. 分离浏览者相关的因素
3. 分离时间因素
4. 异步化地域因素
5. 去掉 Cookie，在缓存静态数据中不含有Cookie
### 动态数据如何处理
1. ESI（Edge Side Includes）方案
	在 Web 代理服务器上做动态内容请求，并将请求插入到静态 页面中，当用户拿到页面时已经是一个完整的页面了。这种方式对服务端性能有些影 响，但是用户体验较好
2. CSI（Client Side Include）方案
	单独发起一个异步 JavaScript 请求，以向服务端获取动态内容。这种方式服务端性能更佳，但是用户端页面可能会延时，体验稍差
## 架构方案
1. 实体机单机部署
2. 统一 Cache 层
3. 上 CDN
# 有效利用系统的热点数据
热点分为热点操作和热点数据
热点数据又分为“静态热点数据”和“动态热点数据”
## 热点数据发掘
1. 发现静态热点数据，卖家发现，自己统计，但这样时效性不高。
2. 通过技术手段提前预测静态热点数据
3. 发现动态热点数据，通过实施日志数据，分析这些日志数据，并反馈给后台。
## 处理热点数据
通常有几种思路:一是优化，二是限制，三是隔离


# 流量削峰
## 削峰的存在
一 是可以让服务端处理变得更加平稳
二是可以节省服务器的资源成本。
## 削峰的方式
- 排队，中间加一层，用作缓冲队列
- 答题，为了增加购买的复杂度
- 分层过滤，在不同的层次尽可能地过滤掉无效请求
	> 在不同的层次尽可能地过滤掉无效请求，让“漏斗”最末端的才是有效请求
# 定位性能瓶颈
- 服务器处理响应的耗时和 QPS
- 线程数对 QPS
## 性能优化（CPU角度）
减少编码、减少序列化、Java 极致优化、并发读优化

# 减库存逻辑设计
## 方式
- 下单减库存
	当用户并发请求到达服务端时，首先创建订单，然后扣除库存，等待用户支付。这种顺序是我们一般人首先会想到的解决方案，这种情况下也能保证订单不会超卖，因为创建订单之后就会减库存，这是一个原子操作。但是这样也会产生一些问题，
	第一就是在极限并发情况下，任何一个内存操作的细节都至关影响性能，尤其像创建订单这种逻辑，一般都需要存储到磁盘数据库的，对数据库的压力是可想而知的；
	第二是如果用户存在恶意下单的情况，只下单不支付这样库存就会变少，会少卖很多订单，虽然服务端可以限制IP和用户的购买订单数量，这也不算是一个好方法。

- 支付减库存
	如果等待用户支付了订单在减库存，第一感觉就是不会少卖。但是这是并发架构的大忌，因为在极限并发情况下，用户可能会创建很多订单，当库存减为零的时候很多用户发现抢到的订单支付不了了，这也就是所谓的“超卖”。也不能避免并发操作数据库磁盘IO

- 预扣库存
	从上边两种方案的考虑，我们可以得出结论：只要创建订单，就要频繁操作数据库IO。那么有没有一种不需要直接操作数据库IO的方案呢，这就是预扣库存。先扣除了库存，保证不超卖，然后异步生成用户订单，这样响应给用户的速度就会快很多；那么怎么保证不少卖呢？用户拿到了订单，不支付怎么办？我们都知道现在订单都有有效期，比如说用户五分钟内不支付，订单就失效了，订单一旦失效，就会加入新的库存，这也是现在很多网上零售企业保证商品不少卖采用的方案。订单的生成是异步的,一般都会放到MQ、kafka这样的即时消费队列中处理,订单量比较少的情况下，生成订单非常快，用户几乎不用排队。


## 大型秒杀中如何减库存
业务系统中最常见的就是**预扣库存**方案，买家下单后，库存为其保留一定的时间(如 10 分 钟)，超过这个时间，库存将会自动释放，在买家付款 前，系统会校验该订单的库存是否还有保留:如果没有保留，则再次尝试预扣;如果库存 不足(也就是预扣失败)则不允许继续付款;如果预扣成功，则完成付款并实际地减去库存。

秒杀商品采用“下单减库存”更加合

## 极致优化
- 如果减库存逻辑非常单一，秒杀商品减库存直接放到缓存系统中实现
- 如果有比较复杂的减库存逻辑，或者需要使用事务，还是必须在数据库中完成减库存

# 兜底方案
## 高可用建设
1. 架构阶段：架构阶段主要考虑系统的可扩展性和容错性，要避免系统出现单点问题
2. 编码阶段：编码最重要的是保证代码的健壮性
3. 测试阶段：测试主要是保证测试用例的覆盖度
4. 发布阶段：发布时也有一些地方需要注意，因为发布时最容易出现错误，因此要有紧急的回滚机制
5. 运行阶段：运行时是系统的常态，运行态最重要的是对系统的监控要准确及时
6. 故障发生：故障发生时首先最重要的就是及时止损
## 如何针对运行阶段进行处理
1. 降级
2. 限流
3. 拒绝服务
## 其它对应方案
- 防刷
- 限量
优惠券看作一种资源，其生产不是凭空的，而是需要事先申请
- 防重

1. 任何资金操作都需要在平台侧生成业务属性的订单，可以是优惠券发放订单，可以是 返现订单，也可以是借款订单，一定是先有订单再去做资金操作

2. 一定要做好防重，也就是实现幂等处理，并且幂等处理必须是全链路的